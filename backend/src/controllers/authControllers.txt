// import { optionalAuth } from "../middlewares/authMiddleware";

// backend/src/controllers/authControllers.js
const pool = require("../config/db");
const bcrypt = require("bcrypt");
const jwt = require("jsonwebtoken");
const crypto = require("crypto");

// generate 6 digit OTP
const generateOTP = () => {
    return Math.floor(100000 + Math.random() * 900000).toString();
};

// send OTP via email
const sendOTP = async (email, phone, otp, purpose = "verification") => {
    console.log(`OTP for ${email || phone}: ${otp} (Purpose: ${purpose})`);
    return true;
}

// register controller
exports.register = async (req, res) => {
    try {
        const { name, email, phone, password, role, profileImage } = req.body;

        // Validate required fields
        if (!name || !email || !phone || !password || !role) {
            return res.status(400).json({ 
                message: "All fields are required" 
            });
        }

        // Validate role (role)
        const allowedRoles = ["buyer", "builder", "agent"];
        if (!allowedRoles.includes(role)) {
            return res.status(400).json({ 
                message: "Invalid role selected. Must be buyer, builder, or agent" 
            });
        }

        // Validate email format
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        if (!emailRegex.test(email)) {
            return res.status(400).json({ 
                message: "Invalid email format" 
            });
        }

        // Validate phone format (10-15 digits)
        const phoneRegex = /^[0-9]{10,15}$/;
        if (!phoneRegex.test(phone)) {
            return res.status(400).json({ 
                message: "Phone number must be 10-15 digits" 
            });
        }

        // Validate password strength
        if (password.length < 8 || !/[a-zA-Z]/.test(password) || !/[0-9]/.test(password)) {
            return res.status(400).json({ 
                message: "Password must be at least 8 characters with letters and numbers" 
            });
        }

        // Check if email already exists
        const [existing] = await pool.query(
            "SELECT id FROM users WHERE email = ?",
            [email.toLowerCase().trim()]
        );

        if (existing.length > 0) {
            return res.status(409).json({
                message: "This email is already registered. Please login instead.",
            });
        }

        // Check if phone already exists
        const [existingPhone] = await pool.query(
            "SELECT id FROM users WHERE phone = ?",
            [phone]
        );

        if (existingPhone.length > 0) {
            return res.status(409).json({
                message: "This phone number is already registered.",
            });
        }

        console.log("Register payload:", { name, email, phone, role, profileImage: profileImage ? 'provided' : 'none' });

        // Hash password
        const hashed = await bcrypt.hash(password, 10);

        // Insert user into database
        const [result] = await pool.query(
            "INSERT INTO users (name, email, phone, password, role, profile_image, created_at) VALUES (?,?,?,?,?,?, NOW())",
            [name.trim(), email.toLowerCase().trim(), phone, hashed, role, profileImage || null]
        );

        const userId = result.insertId;

        // Generate JWT token
        const token = jwt.sign(
            { id: userId, role: role },
            process.env.JWT_SECRET,
            { expiresIn: "7d" }
        );

        // Return success response with token and user data
        res.status(201).json({ 
            message: "Registration successful",
            token,
            user: {
                id: userId,
                name: name.trim(),
                email: email.toLowerCase().trim(),
                phone,
                role: role,
                profileImage: profileImage || null
            }
        });

    } catch (err) {
        console.error("Registration error:", err);
        res.status(500).json({ 
            message: "Server error during registration. Please try again.",
            error: process.env.NODE_ENV === 'development' ? err.message : undefined
        });
    }
};


// login controller
exports.login = async (req, res) => {
    try {
        const { email, password } = req.body;
        const { ipAddress, userAgent } = getRequestMetadata(req);

        // Validate required fields
        if (!email || !password) {
            return res.status(400).json({ 
                message: "Email and password are required" 
            });
        }

        // Find user by email or phone
        const [users] = await pool.query(
            "SELECT * FROM users WHERE email = ? OR phone = ?",
            [email.toLowerCase().trim(), email]
        );

        if (users.length === 0) {
            return res.status(400).json({ 
                message: "Invalid credentials" 
            });
        }

        const user = users[0];

        // Check if user registered via OAuth (no password)
        if (!user.password && (user.google_id || user.microsoft_id)) {
            const provider = user.google_id ? 'Google' : 'Microsoft';
            return res.status(400).json({ 
                message: `This account was created using ${provider}. Please login with ${provider}.` 
            });
        }

        // Check if account is blocked
        if (user.is_blocked) {
            return res.status(403).json({ 
                message: "Your account has been blocked. Please contact support." 
            });
        }

        // Verify password
        const valid = await bcrypt.compare(password, user.password);
        if (!valid) {
            return res.status(400).json({ 
                message: "Invalid credentials" 
            });
        }

        // Generate JWT token
        const token = jwt.sign(
            { id: user.id, role: user.role },
            process.env.JWT_SECRET,
            { expiresIn: "7d" }
        );

        // Log login activity with IP and User-Agent
        await pool.query(
            "INSERT INTO user_login_logs (user_id, login_time, login_method, ip_address, user_agent) VALUES (?, NOW(), 'email', ?, ?)",
            [user.id, ipAddress, userAgent]
        );

        // Update last login timestamp
        await pool.query(
            "UPDATE users SET last_login = NOW() WHERE id = ?",
            [user.id]
        );

        // Return success response
        res.json({
            message: "Login successful",
            token,
            user: {
                id: user.id,
                name: user.name,
                email: user.email,
                phone: user.phone,
                role: user.role,
                profileImage: user.profile_image
            }
        });

    } catch (err) {
        console.error("Login error:", err);
        res.status(500).json({ 
            message: "Server error during login. Please try again.",
            error: process.env.NODE_ENV === 'development' ? err.message : undefined
        });
    }
};


// Optional: Add logout endpoint
exports.logout = async (req, res) => {
    try {
        const { ipAddress, userAgent } = getRequestMetadata(req);

        // Log logout activity
        if (req.user && req.user.id) {
            await pool.query(
                "UPDATE user_login_logs SET logout_time = NOW() WHERE user_id = ? AND logout_time IS NULL ORDER BY login_time DESC LIMIT 1",
                [req.user.id]
            );

            // Optionally log a separate logout entry
            await pool.query(
                "INSERT INTO user_login_logs (user_id, login_time, logout_time, ip_address, user_agent, activity_type, description) VALUES (?, NOW(), NOW(), ?, ?, 'logout', 'User logged out')",
                [req.user.id, ipAddress, userAgent]
            );
        }

        res.json({ message: "Logout successful" });
    } catch (err) {
        console.error("Logout error:", err);
        res.status(500).json({ message: "Server error during logout" });
    }
};

// verifying OTP
exports.verifyOtp = async (req, res) => {
    try {
        const { email, otp, purpose = "email_verification" } = req.body;
        const { ipAddress, userAgent } = getRequestMetadata(req);

        // Validate required fields
        if (!email || !otp) {
            return res.status(400).json({ 
                message: "Email and OTP are required" 
            });
        }

        // Find the most recent OTP for this email and purpose
        const [otpRecords] = await pool.query(
            `SELECT ov.*, u.id as user_id, u.name, u.email, u.phone, u.role, u.profile_image, u.is_verified
             FROM otp_verifications ov
             JOIN users u ON ov.user_id = u.id
             WHERE ov.email = ? AND ov.purpose = ? AND ov.is_used = false
             ORDER BY ov.created_at DESC
             LIMIT 1`,
            [email.toLowerCase().trim(), purpose]
        );

        if (otpRecords.length === 0) {
            return res.status(400).json({ 
                message: "Invalid or expired OTP" 
            });
        }

        const otpRecord = otpRecords[0];

        // Check if OTP has expired
        if (new Date() > new Date(otpRecord.expires_at)) {
            return res.status(400).json({ 
                message: "OTP has expired. Please request a new one." 
            });
        }

        // Verify OTP
        if (otpRecord.otp !== otp) {
            // Increment attempt count
            await pool.query(
                "UPDATE otp_verifications SET attempts = attempts + 1 WHERE id = ?",
                [otpRecord.id]
            );

            return res.status(400).json({ 
                message: "Invalid OTP. Please try again." 
            });
        }

        // Mark OTP as used
        await pool.query(
            "UPDATE otp_verifications SET is_used = true, verified_at = NOW() WHERE id = ?",
            [otpRecord.id]
        );

        // Update user verification status
        await pool.query(
            "UPDATE users SET is_verified = true, email_verified_at = NOW() WHERE id = ?",
            [otpRecord.user_id]
        );

        // Log verification activity with IP and User-Agent
        await pool.query(
            "INSERT INTO user_login_logs (user_id, login_time, ip_address, user_agent, activity_type, description) VALUES (?, NOW(), ?, ?, 'email_verification', 'Email verified successfully')",
            [otpRecord.user_id, ipAddress, userAgent]
        );

        // Generate JWT token
        const token = jwt.sign(
            { id: otpRecord.user_id, role: otpRecord.role },
            process.env.JWT_SECRET,
            { expiresIn: "7d" }
        );

        // Return success response
        res.json({
            message: "Email verified successfully",
            token,
            user: {
                id: otpRecord.user_id,
                name: otpRecord.name,
                email: otpRecord.email,
                phone: otpRecord.phone,
                role: otpRecord.role,
                profileImage: otpRecord.profile_image,
                isVerified: true
            }
        });

    } catch (err) {
        console.error("OTP verification error:", err);
        res.status(500).json({ 
            message: "Server error during OTP verification. Please try again.",
            error: process.env.NODE_ENV === 'development' ? err.message : undefined
        });
    }
};


// resending the OTP
exports.resendOtp = async (req, res) => {
    try {
        const { email, purpose = "email_verification" } = req.body;
        const { ipAddress, userAgent } = getRequestMetadata(req);

        if (!email) {
            return res.status(400).json({ 
                message: "Email is required" 
            });
        }

        const [users] = await pool.query(
            "SELECT id, email, phone, is_verified FROM users WHERE email = ?",
            [email.toLowerCase().trim()]
        );

        if (users.length === 0) {
            return res.status(404).json({ 
                message: "User not found with this email" 
            });
        }

        const user = users[0];

        if (purpose === "email_verification" && user.is_verified) {
            return res.status(400).json({ 
                message: "Email is already verified" 
            });
        }

        const [recentOtps] = await pool.query(
            `SELECT COUNT(*) as count FROM otp_verifications 
             WHERE email = ? AND purpose = ? AND created_at > DATE_SUB(NOW(), INTERVAL 5 MINUTE)`,
            [email.toLowerCase().trim(), purpose]
        );

        if (recentOtps[0].count >= 3) {
            return res.status(429).json({ 
                message: "Too many OTP requests. Please try again after 5 minutes." 
            });
        }

        await pool.query(
            "UPDATE otp_verifications SET is_used = true WHERE email = ? AND purpose = ? AND is_used = false",
            [email.toLowerCase().trim(), purpose]
        );

        const otp = generateOTP();
        const otpExpiry = new Date(Date.now() + 10 * 60 * 1000); // 10 minutes

        await pool.query(
            "INSERT INTO otp_verifications (user_id, email, phone, otp, purpose, expires_at, created_at) VALUES (?,?,?,?,?, ?, NOW())",
            [user.id, email.toLowerCase().trim(), user.phone, otp, purpose, otpExpiry]
        );

        await sendOTP(email, user.phone, otp, purpose);

        // Log OTP resend activity
        await pool.query(
            "INSERT INTO user_login_logs (user_id, login_time, ip_address, user_agent, activity_type, description) VALUES (?, NOW(), ?, ?, 'otp_resend', ?)",
            [user.id, ipAddress, userAgent, `OTP resent for ${purpose}`]
        );

        res.json({ 
            message: "OTP has been resent successfully",
            email: email.toLowerCase().trim()
        });

    } catch (err) {
        console.error("Resend OTP error:", err);
        res.status(500).json({ 
            message: "Server error while resending OTP. Please try again.",
            error: process.env.NODE_ENV === 'development' ? err.message : undefined
        });
    }
};


// forgot password 
exports.forgotPassword = async (req, res) => {
    try {
        const { email } = req.body;
        const { ipAddress, userAgent } = getRequestMetadata(req);

        if (!email) {
            return res.status(400).json({ 
                message: "Email is required" 
            });
        }

        const [users] = await pool.query(
            "SELECT id, email, phone, name, google_id, microsoft_id FROM users WHERE email = ?",
            [email.toLowerCase().trim()]
        );

        if (users.length === 0) {
            return res.json({ 
                message: "If an account exists with this email, you will receive a password reset OTP." 
            });
        }

        const user = users[0];

        // Check if user registered via OAuth (no password to reset)
        if (!user.password && (user.google_id || user.microsoft_id)) {
            const provider = user.google_id ? 'Google' : 'Microsoft';
            return res.status(400).json({ 
                message: `This account was created using ${provider}. Please login with ${provider}.` 
            });
        }

        const [recentOtps] = await pool.query(
            `SELECT COUNT(*) as count FROM otp_verifications 
             WHERE email = ? AND purpose = 'password_reset' AND created_at > DATE_SUB(NOW(), INTERVAL 15 MINUTE)`,
            [email.toLowerCase().trim()]
        );

        if (recentOtps[0].count >= 3) {
            return res.status(429).json({ 
                message: "Too many password reset requests. Please try again after 15 minutes." 
            });
        }

        const otp = generateOTP();
        const otpExpiry = new Date(Date.now() + 15 * 60 * 1000); 

        await pool.query(
            "INSERT INTO otp_verifications (user_id, email, phone, otp, purpose, expires_at, created_at) VALUES (?,?,?,?,?, ?, NOW())",
            [user.id, email.toLowerCase().trim(), user.phone, otp, "password_reset", otpExpiry]
        );

        await sendOTP(email, user.phone, otp, "password_reset");

        // Log password reset request
        await pool.query(
            "INSERT INTO user_login_logs (user_id, login_time, ip_address, user_agent, activity_type, description) VALUES (?, NOW(), ?, ?, 'password_reset_request', 'Password reset OTP requested')",
            [user.id, ipAddress, userAgent]
        );

        res.json({ 
            message: "If an account exists with this email, you will receive a password reset OTP.",
            email: email.toLowerCase().trim()
        });

    } catch (err) {
        console.error("Forgot password error:", err);
        res.status(500).json({ 
            message: "Server error during password reset request. Please try again.",
            error: process.env.NODE_ENV === 'development' ? err.message : undefined
        });
    }
};


// reset password
exports.resetPassword = async (req, res) => {
    try {
        const { email, otp, newPassword } = req.body;
        const { ipAddress, userAgent } = getRequestMetadata(req);

        if (!email || !otp || !newPassword) {
            return res.status(400).json({ 
                message: "Email, OTP, and new password are required" 
            });
        }

        if (newPassword.length < 8 || !/[a-zA-Z]/.test(newPassword) || !/[0-9]/.test(newPassword)) {
            return res.status(400).json({ 
                message: "Password must be at least 8 characters with letters and numbers" 
            });
        }

        const [otpRecords] = await pool.query(
            `SELECT ov.*, u.id as user_id, u.password as current_password
             FROM otp_verifications ov
             JOIN users u ON ov.user_id = u.id
             WHERE ov.email = ? AND ov.purpose = 'password_reset' AND ov.is_used = false
             ORDER BY ov.created_at DESC
             LIMIT 1`,
            [email.toLowerCase().trim()]
        );

        if (otpRecords.length === 0) {
            return res.status(400).json({ 
                message: "Invalid or expired OTP" 
            });
        }

        const otpRecord = otpRecords[0];

        if (new Date() > new Date(otpRecord.expires_at)) {
            return res.status(400).json({ 
                message: "OTP has expired. Please request a new one." 
            });
        }

        if (otpRecord.otp !== otp) {
            await pool.query(
                "UPDATE otp_verifications SET attempts = attempts + 1 WHERE id = ?",
                [otpRecord.id]
            );

            return res.status(400).json({ 
                message: "Invalid OTP. Please try again." 
            });
        }

        const isSamePassword = await bcrypt.compare(newPassword, otpRecord.current_password);
        if (isSamePassword) {
            return res.status(400).json({ 
                message: "New password cannot be the same as your current password" 
            });
        }

        const hashedPassword = await bcrypt.hash(newPassword, 10);

        await pool.query(
            "UPDATE users SET password = ?, password_changed_at = NOW() WHERE id = ?",
            [hashedPassword, otpRecord.user_id]
        );

        await pool.query(
            "UPDATE otp_verifications SET is_used = true, verified_at = NOW() WHERE id = ?",
            [otpRecord.id]
        );

        // Log password reset completion with IP and User-Agent
        await pool.query(
            "INSERT INTO user_login_logs (user_id, login_time, ip_address, user_agent, activity_type, description) VALUES (?, NOW(), ?, ?, 'password_reset', 'Password was reset successfully')",
            [otpRecord.user_id, ipAddress, userAgent]
        );

        res.json({
            message: "Password has been reset successfully. Please login with your new password."
        });

    } catch (err) {
        console.error("Reset password error:", err);
        res.status(500).json({ 
            message: "Server error during password reset. Please try again.",
            error: process.env.NODE_ENV === 'development' ? err.message : undefined
        });
    }
};

// MICROSOFT OAUTH LOGIN
exports.microsoftLogin = async (req, res) => {
    try {
        const { token } = req.body; // Microsoft access token from frontend
        
        if (!token) {
            return res.status(400).json({ 
                message: "Microsoft token is required" 
            });
        }

        // Fetch user info from Microsoft Graph API
        const axios = require('axios');
        const response = await axios.get('https://graph.microsoft.com/v1.0/me', {
            headers: {
                'Authorization': `Bearer ${token}`
            }
        });

        const { id: microsoftId, displayName, mail, userPrincipalName } = response.data;
        const email = mail || userPrincipalName;

        if (!email) {
            return res.status(400).json({ 
                message: "Could not retrieve email from Microsoft account" 
            });
        }

        // Check if user exists
        const [users] = await pool.query(
            "SELECT * FROM users WHERE email = ? OR microsoft_id = ?",
            [email.toLowerCase().trim(), microsoftId]
        );

        let user;
        let isNewUser = false;

        if (users.length > 0) {
            // User exists - update microsoft_id if not set
            user = users[0];
            
            if (!user.microsoft_id) {
                await pool.query(
                    "UPDATE users SET microsoft_id = ?, is_verified = true WHERE id = ?",
                    [microsoftId, user.id]
                );
            }
        } else {
            // Create new user
            isNewUser = true;
            const [result] = await pool.query(
                `INSERT INTO users (name, email, microsoft_id, role, is_verified, email_verified_at, created_at) 
                 VALUES (?, ?, ?, 'buyer', true, NOW(), NOW())`,
                [displayName, email.toLowerCase().trim(), microsoftId]
            );
            
            user = {
                id: result.insertId,
                name: displayName,
                email: email.toLowerCase().trim(),
                microsoft_id: microsoftId,
                role: 'buyer',
                is_verified: true
            };
        }

        // Check if account is blocked
        if (user.is_blocked) {
            return res.status(403).json({ 
                message: "Your account has been blocked. Please contact support." 
            });
        }

        // Generate JWT token
        const jwtToken = jwt.sign(
            { id: user.id, role: user.role },
            process.env.JWT_SECRET,
            { expiresIn: "7d" }
        );

        // Log login activity
        await pool.query(
            "INSERT INTO user_login_logs (user_id, login_time, login_method) VALUES (?, NOW(), 'microsoft')",
            [user.id]
        );

        // Update last login
        await pool.query(
            "UPDATE users SET last_login = NOW() WHERE id = ?",
            [user.id]
        );

        res.json({
            message: isNewUser ? "Account created successfully via Microsoft" : "Login successful via Microsoft",
            token: jwtToken,
            user: {
                id: user.id,
                name: user.name,
                email: user.email,
                phone: user.phone,
                role: user.role,
                profileImage: user.profile_image,
                isVerified: true
            }
        });

    } catch (err) {
        console.error("Microsoft login error:", err);
        res.status(500).json({ 
            message: "Server error during Microsoft login. Please try again.",
            error: process.env.NODE_ENV === 'development' ? err.message : undefined
        });
    }
};




// backend/src/controllers/authControllers.js
const pool = require("../config/db");
const bcrypt = require("bcrypt");
const jwt = require("jsonwebtoken");
const crypto = require("crypto");
const { getRequestMetadata } = require("../utils/requestUtils");

// generate 6 digit OTP
const generateOTP = () => {
    return Math.floor(100000 + Math.random() * 900000).toString();
};

// send OTP via email
const sendOTP = async (email, phone, otp, purpose = "verification") => {
    console.log(`OTP for ${email || phone}: ${otp} (Purpose: ${purpose})`);
    return true;
}


// GOOGLE OAUTH LOGIN
exports.googleLogin = async (req, res) => {
    try {
        const { token } = req.body; 
        const { ipAddress, userAgent } = getRequestMetadata(req);
        
        if (!token) {
            return res.status(400).json({ 
                message: "Google token is required" 
            });
        }

        // Verify Google token
        const { OAuth2Client } = require('google-auth-library');
        const client = new OAuth2Client(process.env.GOOGLE_CLIENT_ID);
        
        const ticket = await client.verifyIdToken({
            idToken: token,
            audience: process.env.GOOGLE_CLIENT_ID,
        });
        
        const payload = ticket.getPayload();
        const { email, name, picture, sub: googleId } = payload;

        // Check if user exists
        const [users] = await pool.query(
            "SELECT * FROM users WHERE email = ? OR google_id = ?",
            [email.toLowerCase().trim(), googleId]
        );

        let user;
        let isNewUser = false;

        if (users.length > 0) {
            // User exists - update google_id if not set
            user = users[0];
            
            if (!user.google_id) {
                await pool.query(
                    "UPDATE users SET google_id = ?, profile_image = COALESCE(profile_image, ?), is_verified = true WHERE id = ?",
                    [googleId, picture, user.id]
                );
            }
        } else {
            // Create new user
            isNewUser = true;
            const [result] = await pool.query(
                `INSERT INTO users (name, email, google_id, profile_image, role, is_verified, email_verified_at, created_at) 
                 VALUES (?, ?, ?, ?, 'buyer', true, NOW(), NOW())`,
                [name, email.toLowerCase().trim(), googleId, picture]
            );
            
            user = {
                id: result.insertId,
                name,
                email: email.toLowerCase().trim(),
                google_id: googleId,
                profile_image: picture,
                role: 'buyer',
                is_verified: true
            };
        }

        // Check if account is blocked
        if (user.is_blocked) {
            return res.status(403).json({ 
                message: "Your account has been blocked. Please contact support." 
            });
        }

        // Generate JWT token
        const jwtToken = jwt.sign(
            { id: user.id, role: user.role },
            process.env.JWT_SECRET,
            { expiresIn: "7d" }
        );

        // Log login activity with IP and User-Agent
        await pool.query(
            "INSERT INTO user_login_logs (user_id, login_time, login_method, ip_address, user_agent) VALUES (?, NOW(), 'google', ?, ?)",
            [user.id, ipAddress, userAgent]
        );

        // Update last login
        await pool.query(
            "UPDATE users SET last_login = NOW() WHERE id = ?",
            [user.id]
        );

        res.json({
            message: isNewUser ? "Account created successfully via Google" : "Login successful via Google",
            token: jwtToken,
            user: {
                id: user.id,
                name: user.name,
                email: user.email,
                phone: user.phone,
                role: user.role,
                profileImage: user.profile_image,
                isVerified: true
            }
        });

    } catch (err) {
        console.error("Google login error:", err);
        res.status(500).json({ 
            message: "Server error during Google login. Please try again.",
            error: process.env.NODE_ENV === 'development' ? err.message : undefined
        });
    }
};


// MICROSOFT OAUTH LOGIN
exports.microsoftLogin = async (req, res) => {
    try {
        const { token } = req.body;
        const { ipAddress, userAgent } = getRequestMetadata(req);
        
        if (!token) {
            return res.status(400).json({ 
                message: "Microsoft token is required" 
            });
        }

        // Fetch user info from Microsoft Graph API
        const axios = require('axios');
        const response = await axios.get('https://graph.microsoft.com/v1.0/me', {
            headers: {
                'Authorization': `Bearer ${token}`
            }
        });

        const { id: microsoftId, displayName, mail, userPrincipalName } = response.data;
        const email = mail || userPrincipalName;

        if (!email) {
            return res.status(400).json({ 
                message: "Could not retrieve email from Microsoft account" 
            });
        }

        // Check if user exists
        const [users] = await pool.query(
            "SELECT * FROM users WHERE email = ? OR microsoft_id = ?",
            [email.toLowerCase().trim(), microsoftId]
        );

        let user;
        let isNewUser = false;

        if (users.length > 0) {
            // User exists - update microsoft_id if not set
            user = users[0];
            
            if (!user.microsoft_id) {
                await pool.query(
                    "UPDATE users SET microsoft_id = ?, is_verified = true WHERE id = ?",
                    [microsoftId, user.id]
                );
            }
        } else {
            // Create new user
            isNewUser = true;
            const [result] = await pool.query(
                `INSERT INTO users (name, email, microsoft_id, role, is_verified, email_verified_at, created_at) 
                 VALUES (?, ?, ?, 'buyer', true, NOW(), NOW())`,
                [displayName, email.toLowerCase().trim(), microsoftId]
            );
            
            user = {
                id: result.insertId,
                name: displayName,
                email: email.toLowerCase().trim(),
                microsoft_id: microsoftId,
                role: 'buyer',
                is_verified: true
            };
        }

        // Check if account is blocked
        if (user.is_blocked) {
            return res.status(403).json({ 
                message: "Your account has been blocked. Please contact support." 
            });
        }

        // Generate JWT token
        const jwtToken = jwt.sign(
            { id: user.id, role: user.role },
            process.env.JWT_SECRET,
            { expiresIn: "7d" }
        );

        // Log login activity with IP and User-Agent
        await pool.query(
            "INSERT INTO user_login_logs (user_id, login_time, login_method, ip_address, user_agent) VALUES (?, NOW(), 'microsoft', ?, ?)",
            [user.id, ipAddress, userAgent]
        );

        // Update last login
        await pool.query(
            "UPDATE users SET last_login = NOW() WHERE id = ?",
            [user.id]
        );

        res.json({
            message: isNewUser ? "Account created successfully via Microsoft" : "Login successful via Microsoft",
            token: jwtToken,
            user: {
                id: user.id,
                name: user.name,
                email: user.email,
                phone: user.phone,
                role: user.role,
                profileImage: user.profile_image,
                isVerified: true
            }
        });

    } catch (err) {
        console.error("Microsoft login error:", err);
        res.status(500).json({ 
            message: "Server error during Microsoft login. Please try again.",
            error: process.env.NODE_ENV === 'development' ? err.message : undefined
        });
    }
};


// REGULAR REGISTRATION
exports.register = async (req, res) => {
    try {
        const { name, email, phone, password, role, profileImage } = req.body;
        const { ipAddress, userAgent } = getRequestMetadata(req);

        // Validate required fields
        if (!name || !email || !phone || !password || !role) {
            return res.status(400).json({ 
                message: "All fields are required" 
            });
        }

        // Validate role (role)
        const allowedRoles = ["buyer", "builder", "agent"];
        if (!allowedRoles.includes(role)) {
            return res.status(400).json({ 
                message: "Invalid role selected. Must be buyer, builder, or agent" 
            });
        }

        // Validate email format
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        if (!emailRegex.test(email)) {
            return res.status(400).json({ 
                message: "Invalid email format" 
            });
        }

        // Validate phone format (10-15 digits)
        const phoneRegex = /^[0-9]{10,15}$/;
        if (!phoneRegex.test(phone)) {
            return res.status(400).json({ 
                message: "Phone number must be 10-15 digits" 
            });
        }

        // Validate password strength
        if (password.length < 8 || !/[a-zA-Z]/.test(password) || !/[0-9]/.test(password)) {
            return res.status(400).json({ 
                message: "Password must be at least 8 characters with letters and numbers" 
            });
        }

        // Check if email already exists
        const [existing] = await pool.query(
            "SELECT id FROM users WHERE email = ?",
            [email.toLowerCase().trim()]
        );

        if (existing.length > 0) {
            return res.status(409).json({
                message: "This email is already registered. Please login instead.",
            });
        }

        // Check if phone already exists
        const [existingPhone] = await pool.query(
            "SELECT id FROM users WHERE phone = ?",
            [phone]
        );

        if (existingPhone.length > 0) {
            return res.status(409).json({
                message: "This phone number is already registered.",
            });
        }

        console.log("Register payload:", { name, email, phone, role, profileImage: profileImage ? 'provided' : 'none' });

        // Hash password
        const hashed = await bcrypt.hash(password, 10);

        // Insert user into database
        const [result] = await pool.query(
            "INSERT INTO users (name, email, phone, password, role, profile_image, created_at) VALUES (?,?,?,?,?,?, NOW())",
            [name.trim(), email.toLowerCase().trim(), phone, hashed, role, profileImage || null]
        );

        const userId = result.insertId;

        // Generate JWT token
        const token = jwt.sign(
            { id: userId, role: role },
            process.env.JWT_SECRET,
            { expiresIn: "7d" }
        );

        // Log registration activity with IP and User-Agent
        await pool.query(
            "INSERT INTO user_login_logs (user_id, login_time, login_method, ip_address, user_agent, activity_type, description) VALUES (?, NOW(), 'email', ?, ?, 'registration', 'User registered successfully')",
            [userId, ipAddress, userAgent]
        );

        // Return success response with token and user data
        res.status(201).json({ 
            message: "Registration successful",
            token,
            user: {
                id: userId,
                name: name.trim(),
                email: email.toLowerCase().trim(),
                phone,
                role: role,
                profileImage: profileImage || null
            }
        });

    } catch (err) {
        console.error("Registration error:", err);
        res.status(500).json({ 
            message: "Server error during registration. Please try again.",
            error: process.env.NODE_ENV === 'development' ? err.message : undefined
        });
    }
};


// REGULAR LOGIN
exports.login = async (req, res) => {
    try {
        const { email, password } = req.body;
        const { ipAddress, userAgent } = getRequestMetadata(req);

        // Validate required fields
        if (!email || !password) {
            return res.status(400).json({ 
                message: "Email and password are required" 
            });
        }

        // Find user by email or phone
        const [users] = await pool.query(
            "SELECT * FROM users WHERE email = ? OR phone = ?",
            [email.toLowerCase().trim(), email]
        );

        if (users.length === 0) {
            return res.status(400).json({ 
                message: "Invalid credentials" 
            });
        }

        const user = users[0];

        // Check if user registered via OAuth (no password)
        if (!user.password && (user.google_id || user.microsoft_id)) {
            const provider = user.google_id ? 'Google' : 'Microsoft';
            return res.status(400).json({ 
                message: `This account was created using ${provider}. Please login with ${provider}.` 
            });
        }

        // Check if account is blocked
        if (user.is_blocked) {
            return res.status(403).json({ 
                message: "Your account has been blocked. Please contact support." 
            });
        }

        // Verify password
        const valid = await bcrypt.compare(password, user.password);
        if (!valid) {
            return res.status(400).json({ 
                message: "Invalid credentials" 
            });
        }

        // Generate JWT token
        const token = jwt.sign(
            { id: user.id, role: user.role },
            process.env.JWT_SECRET,
            { expiresIn: "7d" }
        );

        // Log login activity with IP and User-Agent
        await pool.query(
            "INSERT INTO user_login_logs (user_id, login_time, login_method, ip_address, user_agent) VALUES (?, NOW(), 'email', ?, ?)",
            [user.id, ipAddress, userAgent]
        );

        // Update last login timestamp
        await pool.query(
            "UPDATE users SET last_login = NOW() WHERE id = ?",
            [user.id]
        );

        // Return success response
        res.json({
            message: "Login successful",
            token,
            user: {
                id: user.id,
                name: user.name,
                email: user.email,
                phone: user.phone,
                role: user.role,
                profileImage: user.profile_image
            }
        });

    } catch (err) {
        console.error("Login error:", err);
        res.status(500).json({ 
            message: "Server error during login. Please try again.",
            error: process.env.NODE_ENV === 'development' ? err.message : undefined
        });
    }
};


// LOGOUT
exports.logout = async (req, res) => {
    try {
        const { ipAddress, userAgent } = getRequestMetadata(req);

        // Log logout activity
        if (req.user && req.user.id) {
            await pool.query(
                "UPDATE user_login_logs SET logout_time = NOW() WHERE user_id = ? AND logout_time IS NULL ORDER BY login_time DESC LIMIT 1",
                [req.user.id]
            );

            // Optionally log a separate logout entry
            await pool.query(
                "INSERT INTO user_login_logs (user_id, login_time, logout_time, ip_address, user_agent, activity_type, description) VALUES (?, NOW(), NOW(), ?, ?, 'logout', 'User logged out')",
                [req.user.id, ipAddress, userAgent]
            );
        }

        res.json({ message: "Logout successful" });
    } catch (err) {
        console.error("Logout error:", err);
        res.status(500).json({ message: "Server error during logout" });
    }
};


// OTP VERIFICATION
exports.verifyOtp = async (req, res) => {
    try {
        const { email, otp, purpose = "email_verification" } = req.body;
        const { ipAddress, userAgent } = getRequestMetadata(req);

        // Validate required fields
        if (!email || !otp) {
            return res.status(400).json({ 
                message: "Email and OTP are required" 
            });
        }

        // Find the most recent OTP for this email and purpose
        const [otpRecords] = await pool.query(
            `SELECT ov.*, u.id as user_id, u.name, u.email, u.phone, u.role, u.profile_image, u.is_verified
             FROM otp_verifications ov
             JOIN users u ON ov.user_id = u.id
             WHERE ov.email = ? AND ov.purpose = ? AND ov.is_used = false
             ORDER BY ov.created_at DESC
             LIMIT 1`,
            [email.toLowerCase().trim(), purpose]
        );

        if (otpRecords.length === 0) {
            return res.status(400).json({ 
                message: "Invalid or expired OTP" 
            });
        }

        const otpRecord = otpRecords[0];

        // Check if OTP has expired
        if (new Date() > new Date(otpRecord.expires_at)) {
            return res.status(400).json({ 
                message: "OTP has expired. Please request a new one." 
            });
        }

        // Verify OTP
        if (otpRecord.otp !== otp) {
            // Increment attempt count
            await pool.query(
                "UPDATE otp_verifications SET attempts = attempts + 1 WHERE id = ?",
                [otpRecord.id]
            );

            return res.status(400).json({ 
                message: "Invalid OTP. Please try again." 
            });
        }

        // Mark OTP as used
        await pool.query(
            "UPDATE otp_verifications SET is_used = true, verified_at = NOW() WHERE id = ?",
            [otpRecord.id]
        );

        // Update user verification status
        await pool.query(
            "UPDATE users SET is_verified = true, email_verified_at = NOW() WHERE id = ?",
            [otpRecord.user_id]
        );

        // Log verification activity with IP and User-Agent
        await pool.query(
            "INSERT INTO user_login_logs (user_id, login_time, ip_address, user_agent, activity_type, description) VALUES (?, NOW(), ?, ?, 'email_verification', 'Email verified successfully')",
            [otpRecord.user_id, ipAddress, userAgent]
        );

        // Generate JWT token
        const token = jwt.sign(
            { id: otpRecord.user_id, role: otpRecord.role },
            process.env.JWT_SECRET,
            { expiresIn: "7d" }
        );

        // Return success response
        res.json({
            message: "Email verified successfully",
            token,
            user: {
                id: otpRecord.user_id,
                name: otpRecord.name,
                email: otpRecord.email,
                phone: otpRecord.phone,
                role: otpRecord.role,
                profileImage: otpRecord.profile_image,
                isVerified: true
            }
        });

    } catch (err) {
        console.error("OTP verification error:", err);
        res.status(500).json({ 
            message: "Server error during OTP verification. Please try again.",
            error: process.env.NODE_ENV === 'development' ? err.message : undefined
        });
    }
};


// RESEND OTP
exports.resendOtp = async (req, res) => {
    try {
        const { email, purpose = "email_verification" } = req.body;
        const { ipAddress, userAgent } = getRequestMetadata(req);

        if (!email) {
            return res.status(400).json({ 
                message: "Email is required" 
            });
        }

        const [users] = await pool.query(
            "SELECT id, email, phone, is_verified FROM users WHERE email = ?",
            [email.toLowerCase().trim()]
        );

        if (users.length === 0) {
            return res.status(404).json({ 
                message: "User not found with this email" 
            });
        }

        const user = users[0];

        if (purpose === "email_verification" && user.is_verified) {
            return res.status(400).json({ 
                message: "Email is already verified" 
            });
        }

        const [recentOtps] = await pool.query(
            `SELECT COUNT(*) as count FROM otp_verifications 
             WHERE email = ? AND purpose = ? AND created_at > DATE_SUB(NOW(), INTERVAL 5 MINUTE)`,
            [email.toLowerCase().trim(), purpose]
        );

        if (recentOtps[0].count >= 3) {
            return res.status(429).json({ 
                message: "Too many OTP requests. Please try again after 5 minutes." 
            });
        }

        await pool.query(
            "UPDATE otp_verifications SET is_used = true WHERE email = ? AND purpose = ? AND is_used = false",
            [email.toLowerCase().trim(), purpose]
        );

        const otp = generateOTP();
        const otpExpiry = new Date(Date.now() + 10 * 60 * 1000); // 10 minutes

        await pool.query(
            "INSERT INTO otp_verifications (user_id, email, phone, otp, purpose, expires_at, created_at) VALUES (?,?,?,?,?, ?, NOW())",
            [user.id, email.toLowerCase().trim(), user.phone, otp, purpose, otpExpiry]
        );

        await sendOTP(email, user.phone, otp, purpose);

        // Log OTP resend activity
        await pool.query(
            "INSERT INTO user_login_logs (user_id, login_time, ip_address, user_agent, activity_type, description) VALUES (?, NOW(), ?, ?, 'otp_resend', ?)",
            [user.id, ipAddress, userAgent, `OTP resent for ${purpose}`]
        );

        res.json({ 
            message: "OTP has been resent successfully",
            email: email.toLowerCase().trim()
        });

    } catch (err) {
        console.error("Resend OTP error:", err);
        res.status(500).json({ 
            message: "Server error while resending OTP. Please try again.",
            error: process.env.NODE_ENV === 'development' ? err.message : undefined
        });
    }
};


// FORGOT PASSWORD
exports.forgotPassword = async (req, res) => {
    try {
        const { email } = req.body;
        const { ipAddress, userAgent } = getRequestMetadata(req);

        if (!email) {
            return res.status(400).json({ 
                message: "Email is required" 
            });
        }

        const [users] = await pool.query(
            "SELECT id, email, phone, name, google_id, microsoft_id FROM users WHERE email = ?",
            [email.toLowerCase().trim()]
        );

        if (users.length === 0) {
            return res.json({ 
                message: "If an account exists with this email, you will receive a password reset OTP." 
            });
        }

        const user = users[0];

        // Check if user registered via OAuth (no password to reset)
        if (!user.password && (user.google_id || user.microsoft_id)) {
            const provider = user.google_id ? 'Google' : 'Microsoft';
            return res.status(400).json({ 
                message: `This account was created using ${provider}. Please login with ${provider}.` 
            });
        }

        const [recentOtps] = await pool.query(
            `SELECT COUNT(*) as count FROM otp_verifications 
             WHERE email = ? AND purpose = 'password_reset' AND created_at > DATE_SUB(NOW(), INTERVAL 15 MINUTE)`,
            [email.toLowerCase().trim()]
        );

        if (recentOtps[0].count >= 3) {
            return res.status(429).json({ 
                message: "Too many password reset requests. Please try again after 15 minutes." 
            });
        }

        const otp = generateOTP();
        const otpExpiry = new Date(Date.now() + 15 * 60 * 1000); 

        await pool.query(
            "INSERT INTO otp_verifications (user_id, email, phone, otp, purpose, expires_at, created_at) VALUES (?,?,?,?,?, ?, NOW())",
            [user.id, email.toLowerCase().trim(), user.phone, otp, "password_reset", otpExpiry]
        );

        await sendOTP(email, user.phone, otp, "password_reset");

        // Log password reset request
        await pool.query(
            "INSERT INTO user_login_logs (user_id, login_time, ip_address, user_agent, activity_type, description) VALUES (?, NOW(), ?, ?, 'password_reset_request', 'Password reset OTP requested')",
            [user.id, ipAddress, userAgent]
        );

        res.json({ 
            message: "If an account exists with this email, you will receive a password reset OTP.",
            email: email.toLowerCase().trim()
        });

    } catch (err) {
        console.error("Forgot password error:", err);
        res.status(500).json({ 
            message: "Server error during password reset request. Please try again.",
            error: process.env.NODE_ENV === 'development' ? err.message : undefined
        });
    }
};


// RESET PASSWORD
exports.resetPassword = async (req, res) => {
    try {
        const { email, otp, newPassword } = req.body;
        const { ipAddress, userAgent } = getRequestMetadata(req);

        if (!email || !otp || !newPassword) {
            return res.status(400).json({ 
                message: "Email, OTP, and new password are required" 
            });
        }

        if (newPassword.length < 8 || !/[a-zA-Z]/.test(newPassword) || !/[0-9]/.test(newPassword)) {
            return res.status(400).json({ 
                message: "Password must be at least 8 characters with letters and numbers" 
            });
        }

        const [otpRecords] = await pool.query(
            `SELECT ov.*, u.id as user_id, u.password as current_password
             FROM otp_verifications ov
             JOIN users u ON ov.user_id = u.id
             WHERE ov.email = ? AND ov.purpose = 'password_reset' AND ov.is_used = false
             ORDER BY ov.created_at DESC
             LIMIT 1`,
            [email.toLowerCase().trim()]
        );

        if (otpRecords.length === 0) {
            return res.status(400).json({ 
                message: "Invalid or expired OTP" 
            });
        }

        const otpRecord = otpRecords[0];

        if (new Date() > new Date(otpRecord.expires_at)) {
            return res.status(400).json({ 
                message: "OTP has expired. Please request a new one." 
            });
        }

        if (otpRecord.otp !== otp) {
            await pool.query(
                "UPDATE otp_verifications SET attempts = attempts + 1 WHERE id = ?",
                [otpRecord.id]
            );

            return res.status(400).json({ 
                message: "Invalid OTP. Please try again." 
            });
        }

        const isSamePassword = await bcrypt.compare(newPassword, otpRecord.current_password);
        if (isSamePassword) {
            return res.status(400).json({ 
                message: "New password cannot be the same as your current password" 
            });
        }

        const hashedPassword = await bcrypt.hash(newPassword, 10);

        await pool.query(
            "UPDATE users SET password = ?, password_changed_at = NOW() WHERE id = ?",
            [hashedPassword, otpRecord.user_id]
        );

        await pool.query(
            "UPDATE otp_verifications SET is_used = true, verified_at = NOW() WHERE id = ?",
            [otpRecord.id]
        );

        // Log password reset completion with IP and User-Agent
        await pool.query(
            "INSERT INTO user_login_logs (user_id, login_time, ip_address, user_agent, activity_type, description) VALUES (?, NOW(), ?, ?, 'password_reset', 'Password was reset successfully')",
            [otpRecord.user_id, ipAddress, userAgent]
        );

        res.json({
            message: "Password has been reset successfully. Please login with your new password."
        });

    } catch (err) {
        console.error("Reset password error:", err);
        res.status(500).json({ 
            message: "Server error during password reset. Please try again.",
            error: process.env.NODE_ENV === 'development' ? err.message : undefined
        });
    }
};